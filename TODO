# RayMap â€” Developer Roadmap & Audit Fixes
> Version cible : `v1.2.0` â†’ `v2.0.0`  
> BasÃ© sur l'audit complet de `raymap.h` (1570 lignes) et `raymapvid.h` (807 lignes)  
> Chaque item est **vÃ©rifiÃ© dans le code source** avec rÃ©fÃ©rence de ligne.

---

## LÃ©gende

| Symbole | Signification |
|---|---|
| ðŸ”´ | Bug / Correctness â€” doit Ãªtre corrigÃ© avant release |
| ðŸŸ¡ | Code smell / UX â€” doit Ãªtre corrigÃ© pour niveau pro |
| ðŸŸ¢ | Feature â€” Ã©volution planifiÃ©e |
| âœ… | Aucune action requise â€” dÃ©jÃ  correct |

---

## PHASE 1 â€” Correctness Critique (v1.1.x â†’ v1.2.0)
> **Objectif :** ZÃ©ro bug de correctness dans l'API publique. Aucune rÃ©gression visible par l'utilisateur.

---

### ðŸ”´ FIX-01 â€” `RM_UnmapPoint` incorrect en mode bilinÃ©aire
**Fichier :** `raymap.h` Â· **Ligne :** 1539â€“1552  
**Statut :** ConfirmÃ©, erreur mathÃ©matique certaine.

**ProblÃ¨me :** En mode `RM_MAP_BILINEAR`, `RM_UnmapPoint` utilise l'inverse de la matrice homographique pour revenir en espace UV. Ce n'est pas correct : l'interpolation bilinÃ©aire et la projection homographique sont deux transformations diffÃ©rentes. L'inverse de l'une n'est pas l'inverse de l'autre.

Pour un quad rectangulaire ou lÃ©gÃ¨rement dÃ©formÃ©, l'erreur est faible (~quelques pixels). Pour un quad trÃ¨s en perspective (cas d'usage principal du projection mapping), l'erreur peut dÃ©passer 10â€“20% de la surface.

**Preuve dans le code :**
```c
// ligne 1540-1546 : mode BILINEAR mais on compute/utilise quand mÃªme l'homographie inverse
if (surface->homographyNeedsUpdate) {
    surface->homography = rm_ComputeHomography(surface->quad); // HOMOGRAPHY, pas bilinear
    surface->homographyNeedsUpdate = false;
}
Matrix3x3 invH = rm_Matrix3x3Inverse(surface->homography); // inverse homographie
Vector2 uv = rm_ApplyHomography(invH, screenPoint.x, screenPoint.y); // appliquÃ© au point
```

**Fix :** ImplÃ©menter un vrai inversion bilinÃ©aire. L'Ã©quation bilinÃ©aire `P(u,v) = (1-u)(1-v)P00 + u(1-v)P10 + (1-u)vP01 + uvP11` n'a pas d'inverse analytique simple â€” il faut une rÃ©solution itÃ©rative (Newton-Raphson, 3â€“5 itÃ©rations suffisent pour converger Ã  0.001 pixel).

```c
// Squelette du fix
static Vector2 rm_InverseBilinear(RM_Quad q, Vector2 p) {
    // Initialisation : estimation initiale avec bounding box
    float u = 0.5f, v = 0.5f;
    for (int iter = 0; iter < 8; iter++) {
        Vector2 est = rm_BilinearInterpolation(q.topLeft, q.topRight, q.bottomLeft, q.bottomRight, u, v);
        // Calcul du rÃ©sidu et de la Jacobienne
        // ... Newton-Raphson step ...
        // Clamp u,v Ã  [0,1] Ã  chaque itÃ©ration
    }
    return (Vector2){ u, v };
}
```

**Impact :** `RM_UnmapPoint` retourne des coordonnÃ©es UV incorrectes en mode bilinÃ©aire. Toute application qui fait du hit-testing (clic dans la surface mappÃ©e) sera erronÃ©e.

---

### ðŸ”´ FIX-02 â€” `__attribute__((unused))` non portable (MSVC)
**Fichier :** `raymap.h` Â· **Lignes :** 438, 464  

**ProblÃ¨me :** `__attribute__((unused))` est une extension GCC/Clang. Sur MSVC (`cl.exe`), Ã§a ne compile pas. Raylib supporte Windows officiellement â€” une lib dans son Ã©cosystÃ¨me doit faire pareil.

**Preuve dans le code :**
```c
// ligne 438
__attribute__((unused))
static Matrix3x3 rm_Matrix3x3Multiply(Matrix3x3 a, Matrix3x3 b)

// ligne 464
__attribute__((unused))
static Matrix3x3 rm_Matrix3x3Inverse(Matrix3x3 m)
```

**Fix A (immÃ©diat) :** Macro portable Ã  ajouter dans la section defines :
```c
#if defined(__GNUC__) || defined(__clang__)
    #define RM_UNUSED __attribute__((unused))
#elif defined(_MSC_VER)
    #define RM_UNUSED
#else
    #define RM_UNUSED
#endif
```
Puis remplacer `__attribute__((unused))` par `RM_UNUSED`.

**Fix B (meilleur) :** `rm_Matrix3x3Multiply` et `rm_Matrix3x3Inverse` ne sont marquÃ©es `unused` que parce qu'elles ne sont pas appelÃ©es dans tous les paths de compilation. Si elles font partie de l'API interne prÃ©vue pour usage futur, les garder avec `RM_UNUSED`. Si `rm_Matrix3x3Inverse` est utilisÃ©e dans `RM_UnmapPoint` (ligne 1545), le `unused` est dÃ©jÃ  faux â€” vÃ©rifier et supprimer le marqueur.

---

### ðŸ”´ FIX-03 â€” `RM_IsCalibrating` appelle du input raylib
**Fichier :** `raymap.h` Â· **Ligne :** 1292â€“1295  

**ProblÃ¨me :** `RM_IsCalibrating` prend `RM_Calibration` par valeur (lecture seule sÃ©mantiquement) mais appelle `IsMouseButtonDown(MOUSE_BUTTON_LEFT)` â€” une fonction d'input hardware. Cette fonction ne devrait pas interroger le hardware. Si elle est appelÃ©e deux fois par frame, on dÃ©pend de l'ordre d'appel. Si elle est appelÃ©e hors du game loop (ex: dans un thread sÃ©parÃ©), comportement non dÃ©fini.

**Preuve dans le code :**
```c
// ligne 1292-1295
RMAPI bool RM_IsCalibrating(RM_Calibration calibration)
{
    return (calibration.activeCorner >= 0 && IsMouseButtonDown(MOUSE_BUTTON_LEFT)); // â† PROBLÃˆME
}
```

**Fix :** Ajouter un champ `isDragging` dans `RM_Calibration`, mis Ã  jour dans `RM_UpdateCalibration` :
```c
// Dans RM_Calibration (raymap.h, struct publique ligne 86)
bool isDragging;   // true quand un coin est en cours de drag

// Dans RM_UpdateCalibration :
calibration->isDragging = (IsMouseButtonDown(MOUSE_BUTTON_LEFT) && calibration->activeCorner >= 0);

// RM_IsCalibrating devient pur :
RMAPI bool RM_IsCalibrating(RM_Calibration calibration) {
    return calibration.isDragging;
}
```

**Note :** Ce changement est une breaking change mineure sur la struct `RM_Calibration`. Ã€ faire dans une v1.2.0 avec note de changelog.

---

### ðŸ”´ FIX-04 â€” `const` cast-away dans `RMV_GetVideoTexture`
**Fichier :** `raymapvid.h` Â· **Ligne :** 614  

**ProblÃ¨me :** La fonction dÃ©clare `const RMV_Video *video` mais cast en `RMV_Video *` pour modifier l'Ã©tat interne (lazy texture creation). C'est du Undefined Behavior en C si l'objet original a Ã©tÃ© dÃ©clarÃ© `const`. Ã€ minima c'est une violation du contrat de l'interface.

**Preuve dans le code :**
```c
// ligne 613-616
if (!video->textureCreated) {
    RMV_Video *v = (RMV_Video *)video; // â† cast-away const : UB potentiel
    if (!rmv_CreateTexture(v)){
```

**Fix option A :** Retirer `const` de `RMV_GetVideoTexture` â€” la fonction mute l'Ã©tat, donc elle n'est pas const.
```c
RMVAPI Texture2D RMV_GetVideoTexture(RMV_Video *video); // plus honnÃªte
```

**Fix option B (plus propre) :** DÃ©placer la lazy init dans `RMV_UpdateVideo`. Quand l'Ã©tat passe Ã  PLAYING pour la premiÃ¨re fois, crÃ©er la texture. `RMV_GetVideoTexture` reste `const` et retourne simplement `video->texture`. C'est l'approche recommandÃ©e.

---

### ðŸ”´ FIX-05 â€” `rmv_GetFFmpegError` buffer statique non-rÃ©entrant
**Fichier :** `raymapvid.h` Â· **Ligne :** 323â€“327  

**ProblÃ¨me :** Le buffer est `static char errorBuf[...]`. Si deux erreurs FFmpeg sont loggÃ©es dans la mÃªme expression ou si la fonction est appelÃ©e depuis deux contextes, le second appel Ã©crase le buffer avant que le premier log soit affichÃ©.

**Preuve dans le code :**
```c
// ligne 323-327
static const char* rmv_GetFFmpegError(int errorCode){
    static char errorBuf[AV_ERROR_MAX_STRING_SIZE]; // â† non-rÃ©entrant
    av_strerror(errorCode, errorBuf, sizeof(errorBuf));
    return errorBuf;
}
```

**Fix :** Passer Ã  un buffer caller-allocated ou utiliser `AV_ERROR_MAX_STRING_SIZE` sur la stack localement dans chaque site d'appel :
```c
// Option simple : macro inline
#define RMV_FFERR(code) (av_strerror((code), (char[AV_ERROR_MAX_STRING_SIZE]){0}, AV_ERROR_MAX_STRING_SIZE), "ffmpeg_error")
// Ou plus proprement, utiliser av_err2str (si disponible selon la version FFmpeg)
```

---

## PHASE 2 â€” QualitÃ© & Robustesse (v1.2.0 â†’ v1.3.0)
> **Objectif :** Code dÃ©fensif, comportements prÃ©visibles, zÃ©ro surprise pour un contributeur externe.

---

### ðŸŸ¡ FIX-06 â€” Nom `rm_GenerateBilinearMesh` trompeur
**Fichier :** `raymap.h` Â· **Ligne :** 699  

**ProblÃ¨me :** La fonction gÃ©nÃ¨re le mesh pour les DEUX modes (bilinear ET homographique) selon `surface->mode`. Le nom laisse entendre qu'elle ne fait que du bilinÃ©aire. Un contributeur qui lit le code 6 mois plus tard cherchera une `rm_GenerateHomographyMesh` qui n'existe pas.

**Fix :** Renommer en `rm_RebuildMesh` ou `rm_GenerateMesh`. Mettre Ã  jour l'appel dans `rm_EnsureMeshUpdated` (ligne 832).

---

### ðŸŸ¡ FIX-07 â€” IncohÃ©rence limite mesh : 256 interne vs 64 public
**Fichier :** `raymap.h` Â· **Lignes :** 707 (interne) et 1006â€“1009 (public)

**ProblÃ¨me :** `rm_GenerateBilinearMesh` accepte jusqu'Ã  256x256 colonnes/lignes. `RM_SetMeshResolution` clamp Ã  64x64. Si quelqu'un appelle la fonction interne directement (ou si un futur refactor bypass l'API), on peut crÃ©er des meshes que l'API publique interdit.

**Fix :** DÃ©finir une constante partagÃ©e :
```c
#define RM_MESH_MIN_RESOLUTION   4
#define RM_MESH_MAX_RESOLUTION  64   // une seule source de vÃ©ritÃ©
```
Et l'utiliser dans les deux endroits. Supprimer le check `> 256` dans la fonction interne puisque l'API publique garantit dÃ©jÃ  le clamp.

---

### ðŸŸ¡ FIX-08 â€” `sscanf` sans vÃ©rification du retour (3 coins sur 4)
**Fichier :** `raymap.h` Â· **Lignes :** 1402, 1406, 1409

**ProblÃ¨me :** Seul `topLeft` vÃ©rifie le retour de `sscanf`. Les 3 autres coins lisent silencieusement des donnÃ©es potentiellement malformÃ©es sans signal d'erreur.

**Preuve dans le code :**
```c
// ligne 1398 : check prÃ©sent âœ…
if (sscanf(value, "%f,%f", &quad.topLeft.x, &quad.topLeft.y) == 2) { quadLoaded = true; }

// lignes 1403, 1407, 1410 : pas de check âŒ
sscanf(value, "%f,%f", &quad.topRight.x, &quad.topRight.y);
sscanf(value, "%f,%f", &quad.bottomRight.x, &quad.bottomRight.y);
sscanf(value, "%f,%f", &quad.bottomLeft.x, &quad.bottomLeft.y);
```

**Fix :** Appliquer le mÃªme pattern sur les 4 coins. Retourner `false` si un coin est mal formÃ©.

---

### ðŸŸ¡ FIX-09 â€” Config I/O ignore `width` et `height` du fichier de config
**Fichier :** `raymap.h` Â· **Lignes :** 1360â€“1411

**ProblÃ¨me :** `RM_SaveConfig` Ã©crit `width` et `height`. `RM_LoadConfig` les lit et les ignore. Si l'utilisateur charge une config sur une surface de dimensions diffÃ©rentes, les coordonnÃ©es du quad sont hors limites â€” aucun avertissement.

**Fix :** AprÃ¨s parsing, vÃ©rifier si les dimensions chargÃ©es diffÃ¨rent de `surface->width/height` et logguer un `LOG_WARNING`. Optionnel : retourner `false` si les dimensions sont incompatibles (breaking change, Ã  documenter).

```c
// Ã€ ajouter aprÃ¨s le parsing
int loadedWidth = 0, loadedHeight = 0;
// ... parser width et loadedHeight ...
if (loadedWidth > 0 && loadedWidth != surface->width) {
    TraceLog(LOG_WARNING, "RAYMAP: LoadConfig - Config width (%d) differs from surface width (%d)",
             loadedWidth, surface->width);
}
```

---

### ðŸŸ¡ FIX-10 â€” Grille de calibration incorrecte en mode homographique
**Fichier :** `raymap.h` Â· **Lignes :** 1233â€“1246

**ProblÃ¨me :** `RM_DrawCalibrationGrid` utilise `Vector2Lerp` (interpolation linÃ©aire) pour tracer la grille. En mode `RM_MAP_BILINEAR`, c'est correct. En mode `RM_MAP_HOMOGRAPHY`, les lignes devraient Ãªtre perspectivÃ©es â€” elles sont en rÃ©alitÃ© lÃ©gÃ¨rement courbes Ã  cause de la division par `w`. La grille affichÃ©e ne correspond pas Ã  la dÃ©formation rÃ©elle du mesh.

**Impact UX :** L'artiste de mapping voit une grille qui ne reprÃ©sente pas fidÃ¨lement ce qu'il projette. C'est le cas d'usage principal de la lib.

**Fix :** Passer par `RM_MapPoint` pour chaque point de grille au lieu de `Vector2Lerp` :
```c
// Pour chaque intersection de grille (u, v) :
Vector2 screenPos = RM_MapPoint(surface, (Vector2){ u, v });
```
Ceci utilise automatiquement le bon mode (bilinÃ©aire ou homographique).

---

### ðŸŸ¡ FIX-11 â€” Boucle decode sans limite d'itÃ©rations dans `RMV_UpdateVideo`
**Fichier :** `raymapvid.h` Â· **Ligne :** 656

**ProblÃ¨me :** `while (!frameDecoded)` peut boucler indÃ©finiment sur un stream corrompu, un codec qui refuse de produire des frames, ou sur certains fichiers avec des streams audio-only intercalÃ©s.

**Fix :** Ajouter un compteur de sÃ©curitÃ© :
```c
int safetyCounter = 0;
while (!frameDecoded && safetyCounter < 1000) {
    safetyCounter++;
    // ... decode logic ...
}
if (safetyCounter >= 1000) {
    TraceLog(LOG_ERROR, "RAYMAPVID: Decode loop safety limit reached, possible corrupt stream");
    video->state = RMV_STATE_ERROR;
}
```

---

### ðŸŸ¡ FIX-12 â€” `codecName` et `formatName` pointent vers des strings FFmpeg internes
**Fichier :** `raymapvid.h` Â· **Lignes :** 457â€“458

**ProblÃ¨me :** Ces pointeurs sont valides tant que `formatCtx` et `codecCtx` sont ouverts. AprÃ¨s `RMV_UnloadVideo`, ils deviennent dangling. Si l'utilisateur stocke un `RMV_VideoInfo` et l'utilise aprÃ¨s unload, c'est un use-after-free.

**Preuve dans le code :**
```c
video->codecName = avcodec_get_name(codecParams->codec_id);  // pointeur interne FFmpeg
video->formatName = video->formatCtx->iformat->name;          // pointeur interne FFmpeg
```

**Fix :** Dupliquer les strings Ã  l'allocation :
```c
video->codecName = strdup(avcodec_get_name(codecParams->codec_id));
video->formatName = strdup(video->formatCtx->iformat->name);
// Et les free() dans rmv_CleanupVideo
```
Note : `strdup` n'est pas C99 standard (c'est POSIX). Pour portabilitÃ© maximale, implÃ©menter `rmv_strdup` avec `malloc + strcpy`.

---

## PHASE 3 â€” Features & Ergonomie (v1.3.0 â†’ v2.0.0)
> **Objectif :** Rendre la lib utilisable dans des setups pro (multi-surface, multi-Ã©cran, edge blending).

---

### ðŸŸ¢ FEAT-01 â€” Versionning du format de config
**PrioritÃ© :** Haute (avant d'ajouter de nouvelles features config)

Ajouter `version=1` dans le fichier de config et refuser le chargement de versions inconnues. Toute nouvelle feature qui ajoute des champs dans le fichier doit bumper la version.

---

### ðŸŸ¢ FEAT-02 â€” Labels de coins dans la calibration
**PrioritÃ© :** Moyenne

Remplacer les index `0,1,2,3` par des labels `TL, TR, BR, BL` dans `RM_DrawCalibrationCorners`. Ajouter un champ `cornerLabels[4]` dans `RM_CalibrationConfig` pour permettre la customisation.

---

### ðŸŸ¢ FEAT-03 â€” `RM_SetSurfaceAlpha` â€” opacitÃ© globale
**PrioritÃ© :** Moyenne

Pour le projection mapping, le cross-fading et l'edge blending sont essentiels. Ajouter un champ `float alpha` dans `RM_Surface` et l'appliquer via la couleur tint de `DrawMesh`.

---

### ðŸŸ¢ FEAT-04 â€” Support multi-surface avec z-order
**PrioritÃ© :** Haute (cas d'usage pro)

Ajouter `int zOrder` dans `RM_Surface` et une fonction `RM_DrawSurfacesSorted(RM_Surface **surfaces, int count)` qui trie et dessine par z-order.

---

### ðŸŸ¢ FEAT-05 â€” `RMV_SeekVideo` â€” seek temporel
**PrioritÃ© :** Haute pour raymapvid

L'API actuelle n'expose aucune fonction de seek. Pour du mapping VJ live, le seek est indispensable.
```c
RMVAPI bool RMV_SeekVideo(RMV_Video *video, float seconds);
```
ImplÃ©mentation : `av_seek_frame` + `avcodec_flush_buffers`.

---

### ðŸŸ¢ FEAT-06 â€” Hardware acceleration (RMV_HWACCEL_AUTO)
**PrioritÃ© :** Basse (v2.0)

L'enum `RMV_HWAccelType` est dÃ©jÃ  dÃ©fini mais `RMV_GetVideoInfo` retourne toujours `RMV_HWACCEL_NONE` (ligne 600). ImplÃ©menter la dÃ©tection et l'activation HW via `av_hwdevice_ctx_create`.

---

### ðŸŸ¢ FEAT-07 â€” `RM_SaveConfig` / `RM_LoadConfig` multi-surface
**PrioritÃ© :** Moyenne

Un setup de mapping rÃ©el a 2â€“8 surfaces. Ajouter :
```c
RMAPI bool RM_SaveConfigAll(RM_Surface **surfaces, int count, const char *filepath);
RMAPI bool RM_LoadConfigAll(RM_Surface **surfaces, int count, const char *filepath);
```

---

## RÃ©sumÃ© des phases

| Phase | Version | Items | Effort estimÃ© |
|---|---|---|---|
| Phase 1 â€” Correctness | v1.2.0 | FIX-01 Ã  FIX-05 | 2â€“4 jours |
| Phase 2 â€” QualitÃ© | v1.3.0 | FIX-06 Ã  FIX-12 | 3â€“5 jours |
| Phase 3 â€” Features | v2.0.0 | FEAT-01 Ã  FEAT-07 | 2â€“4 semaines |

---

## Ordre de prioritÃ© absolu (si tu ne peux faire qu'une chose)

```
FIX-02 (portabilitÃ© MSVC)     â†’ 30 min, impact immÃ©diat
FIX-03 (RM_IsCalibrating)     â†’ 1h, correction de design
FIX-08 (sscanf checks)        â†’ 30 min, robustesse parsing
FIX-04 (const cast-away)      â†’ 1h, UB potentiel
FIX-09 (config width/height)  â†’ 1h, data integrity
FIX-06 (renommage mesh)       â†’ 15 min, lisibilitÃ©
FIX-07 (limite mesh cohÃ©rente)â†’ 30 min, constantes partagÃ©es
FIX-10 (grille calibration)   â†’ 2h, correction UX majeure
FIX-05 (buffer FFmpeg)        â†’ 1h, fiabilitÃ© logs
FIX-11 (boucle decode)        â†’ 30 min, sÃ©curitÃ©
FIX-12 (strings FFmpeg)       â†’ 1h, memory safety
FIX-01 (UnmapPoint bilinear)  â†’ 4â€“8h, algorithme non trivial
```

---

*Roadmap gÃ©nÃ©rÃ©e sur audit complet du code source â€” chaque item est vÃ©rifiable Ã  la ligne indiquÃ©e.*  
*Auteur de l'audit : Claude Sonnet 4.6 â€” FÃ©vrier 2026*
